# GOT and plt на примере

Объясним GOT и plt на примере: откроем дебагер и посмотрим, как это работает.

### Обозначения:
* GOT - таблица GLOBAL_OFFSET_TABLE
    содержит первые 3 служебных записи (см [1]) и **абсолютные** адреса функций
    из разделяемых библиотек (абсолютный адрес в контексте данного процесса)
* GOT[FUNC] - ячейка GOT, соответствующая функции func

* plt - область памяти, содержащая трамплины на функции
    содержит по трамплину для каждой функции из разделяемой библиотеки
    мы можем рассматривать ее как **таблицу трамплинов**
* func@puts - трамплин из plt-секции, соответствующий функции func
* plt[0] - общая часть всех plt-трамплинов, условно можно считать первой 
    функцией в таблице plt-трамплинов (располагается первой в памяти)

### Пример

Скомпилируем с символами следующую простую программу:
```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    puts("puts called first time\n");
    int i;
    sscanf(" 1 ", "%d", &i);
    puts("puts called second time\n");
    sscanf(" 2 ", "%d", &i);
    return 0;
}
```
```bash
gcc -o demo_got demo_got.c -g
```
Теперь рассмотрим ее в gdb (с [peda](https://github.com/longld/peda) будет удобнее!)
Мы установим брейк на второй вызов функции puts. На этом этапе puts и sscanf
уже вызывались один раз. Запустим программу и дизассемблируем несколько
инструкций, которые должны выполниться после брейка (брейк установлен на
*(&main + 50)):

    => 0x4005cf <main+50>:     call   0x400470 <puts@plt>
    gdb-peda$ pdisass 0x400470
	0x400470 <puts@plt+0>:     jmp    QWORD PTR [rip+0x200ba2] # GOT[puts]

То есть puts@plt это трамплин, который берет адрес из GOT[puts] и прыгает на
него.  Распечатаем содержимое GOT таблицы (и научимся небольшому трюку с gdb).
Сейчас нас интересуют GOT[puts] и GOT[scanf] по смещениям 0х24 и 0х48
соответственно. В таблице сокращены некоторые адреса для экономии места и
внимания:

	gdb-peda$ set $GOT = (void **)&_GLOBAL_OFFSET_TABLE_
	gdb-peda$ telescope $GOT
	0000| 0x601000 --> 0x600e28 
	0008| 0x601008 --> 0x7ffff7ffe1c8 
	0016| 0x601010 --> 0x7ffff7df04a0   (<_dl_runtime_resolve>)
	0024| 0x601018 --> 0x7ffff7a81d60   (<_IO_puts>)
	0032| 0x601020 --> 0x7ffff7a33e50   (<__libc_start_main>)
	0040| 0x601028 --> 0x400496         (<__gmon_start__@plt+6>)
	0048| 0x601030 --> 0x7ffff7a70390   (<__isoc99_sscanf>)

Как видим, таблица содержит адрес IO_puts и isoc99_sscanf - это те функции, 
которые вызываются во время call puts и call isoc99_sscan соответственно.
Сделаем то же самое, но поставим break на первый вызов puts. Теперь мы
остановимся до первого вызова функций, и таблица будет иметь следующий вид:

	gdb-peda$ telescope $GOT
    0000| 0x601000 --> 0x600e28 --> 0x1
	0008| 0x601008 --> 0x7ffff7ffe1c8 --> 0x0
	0016| 0x601010 --> 0x7ffff7df04a0   (<_dl_runtime_resolve>)
	0024| 0x601018 --> 0x400476         (<puts@plt+6>)
	0032| 0x601020 --> 0x7ffff7a33e50   (<__libc_start_main>)
	0040| 0x601028 --> 0x400496         (<__gmon_start__@plt+6>)
	0048| 0x601030 --> 0x4004a6         (<__isoc99_sscanf@plt+6>)

В этот раз GOT[puts] и GOT[sscanf] содержат адреса из plt секции, а не из
области, в которую загружена libc! Вернемся к puts@plt и посмотрим, что
происходит при первом вызове puts. Выполнится следующая последовательность
команд:

    => 0x4005aa <main+13>:     call   0x400470 <puts@plt>
	0x400470 <puts@plt+0>:     jmp    QWORD PTR [rip+0x200ba2] # GOT[puts]
	0x400476 <puts@plt+6>:     push   0x0					   # push reloc_arg
	0x40047b <puts@plt+11>:    jmp    0x400460				   # jump to plt[0]

То есть до первого вызова puts ячейка GOT[puts] содержит адрес puts@plt+6, и
абсолютный переход jmp QWORD PTR GOT[puts] просто перепрыгивает на следующую
инструкцию, как будто абсолютного перехода вообще. plt[0] это часть
wrapper_fixup.  Детали его работы не входят в данную демонстрацию. Если
коротко, то он:
* запомнит, что нужно вызвать puts, и сохранит аргументы для puts
* найдет адрес puts в разделяемой библиотеке
* вызовет puts с сохраненными аргументами

Если зайти внутрь (gdb $ si), затем продолжить до выхода из функции (gdb $fin)
и распечатать таблицу GOT, то мы заметим, что ячейка GOT[puts] теперь содержит
адрес, указывающий на область libc, а не на plt секцию.

Аналогично, после первого вызова sscanf будет изменена ячейка GOT[sscanf]. При
последующих вызовах ячейки соответствующих функций уже не будут меняться.

**Замечание** Из-за того, что до первого вызова GOT[func] содержит адрес из
plt, нужно внимательно следить, какая ячейка из GOT используется в memory-leak
для определения адреса загрузки libc.

### результат

Работа рантайм линкера может быть проиллюстрирована псевдокодом:
```python
def func_plt(args):
    if not GOT[func_index]:
        GOT[func_index] = wrapper_fixup(func_ord)
    # GOT[func_index] == &func here
    return GOT[func_index](args)
```

### рекомендуемая литература

* 1: [Study of ELF loading and relocs](http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html)
* 2: [ELF](http://www.cs.stevens.edu/~jschauma/631A/elf.html)
* 3: Oracle docs - [runtime linker](https://docs.oracle.com/cd/E26502_01/html/E26507/chapter3-1.html#scrolltoc)
